package salsa_lite.compiler;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;

import salsa_lite.compiler.definitions.CompilerErrors;
import salsa_lite.compiler.definitions.CCompilationUnit;

import salsa_lite.compiler.symbol_table.SymbolTable;

/**
 * $Id: SalsaCompiler.java,v 1.1 2007/07/31 14:06:38 deselt Exp $
 * <p>
 * This is the Salsa programming language compiler. Compilation goes through two
 * major steps:
 * <p>
 * (1) Parsing phase: Here we call the Salsa Parser. As generated by JavaCC with
 * a few changes to keep the input for code generation.
 * <p>
 * (2) Code Generation phase: Here we use the abstract syntax tree produced by
 * the first phase to build Java files corresponding to the original Salsa files
 * being compiled.
 * <p>
 * Modified by Robin D. Toll 2001/12 -Re-coded parameter handling. Modified by
 * Travis Desell 2003/7 -Re-write of the grammer and code generation for salsa
 * 0.6.0
 * 
 * @author Carlos Varela cvarela@uiuc.edu 1999/09/14
 * @version 0.3.3 2002/04/02
 */
public class SalsaCompiler {
	public static final String VERSION = "0.0.1";
	private String[] files = null;
	private List<String> fileList = new ArrayList<String>();
	private ArrayList<String> classPaths = new ArrayList<String>();

    public static boolean compilationSuccess = true;


	public static String convertToPath(String objectName) {
		StringTokenizer stringTokenizer = new StringTokenizer(objectName, ".");

		String path = "";
		while (stringTokenizer.hasMoreTokens()) {
			path += stringTokenizer.nextToken();
			if (stringTokenizer.hasMoreTokens())
				path += File.separator;
		}
		return path;
	}

	public static void main(String args[]) {
		new SalsaCompiler(args);
	}

	SalsaCompiler(String[] args) {
		SalsaParser parser = null;
		String stateFile = null;
		String referenceFile = null;

		classPaths = new ArrayList<String>();
		StringTokenizer stringTokenizer = new StringTokenizer(System.getProperty("java.class.path", "."), ":;");
		for (; stringTokenizer.hasMoreElements();) {
			classPaths.add(stringTokenizer.nextToken());
		}
		// Add the current directory
		classPaths.add(System.getProperty("user.dir"));

		if (args.length == 0) {
			if (System.getProperty("silent") == null) {
				System.out.println("SalsaLite Compiler Version " + VERSION + ":  Reading from standard input . . .");
				parser = new SalsaParser(System.in);
			}
		} else {
			for (int x = 0; x < args.length; x++) {
				if (args[x].equals("-?")) help();
				else addFile(args[x]);
			}
			files = fileList.toArray(new String[1]);
			if ((files == null) || (files.length < 1)) {
				if (System.getProperty("silent") == null) {
					System.out.println("SalsaLite Compiler Version " + VERSION + ":  Reading from standard input . . .");
				}
				parser = new SalsaParser(System.in);
			}

			for (int x = 0; x < files.length; x++) {
				if (System.getProperty("silent") == null) {
					System.out.println();
					System.out.println("SalsaLite Compiler Version " + VERSION + ":  Reading from file " + files[x] + " . . .");
				}

				try {
					String working_directory = files[x].substring(0, files[x].lastIndexOf(File.separatorChar) + 1);
                    CompilerErrors.initialize(files[x]);
                    SalsaParser.currentFilename = files[x];

					if (x == 0) {
						SymbolTable.setWorkingDirectory(working_directory);
						parser = new SalsaParser(new java.io.FileInputStream( files[x]));
					} else {
						SymbolTable.setWorkingDirectory(working_directory);
						parser.ReInit(new java.io.FileInputStream(files[x]));
					}

					if (!files[x].endsWith(".salsa")) {
						System.out.println("SalsaLite Compiler Version " + VERSION + ":  File must end with \".salsa\"");
					} else { 
						// Okay, it's passed all our tests; lets actually
						// compile it.
						String temp = files[x].substring(0, files[x].length() - 6);
						
						referenceFile = temp + ".java";
						stateFile = temp + "State.java";
					}

					try {
						CCompilationUnit cu = parser.CompilationUnit();
						SymbolTable.resetSymbolTable(cu);

						if (System.getProperty("silent") == null) {
                            if (compilationSuccess) {
                                System.out.println("SalsaLite Compiler Version " + VERSION + ":  Salsa program parsed successfully.");
                            } else {
                                System.out.println("SalsaLite Compiler Version " + VERSION + ":  Salsa program parsed unsuccessfully.");
                            }
						}

						if (referenceFile != null) {
                            new FileOutputStream(referenceFile).write(cu.getStateCode().getBytes());
						} else {
                            System.out.println(cu.getStateCode());
						}

						if (System.getProperty("silent") == null) {
                            if (compilationSuccess) {
                                System.out.println("SalsaLite Compiler Version " + VERSION + ":  Salsa program compiled successfully.");
                            } else {
                                System.out.println("SalsaLite Compiler Version " + VERSION + ":  Salsa program compiled unsuccessfully.");
                            }
						}
					} catch (IOException e) {
						System.out.println(e.getMessage());
						System.out.println("SalsaLite Compiler Version " + VERSION + ":  Encountered errors writing to file:" + referenceFile);
						System.out.println("SalsaLite Compiler Version " + VERSION + ":  Encountered errors writing to file:" + stateFile);
					} catch (ParseException e) {
						System.out.println(e.getMessage());
						System.out.println("SalsaLite Compiler Version " + VERSION + ":  Encountered errors during parse.");
					}
				} catch (java.io.FileNotFoundException e) {
					System.out.println("SalsaLite Compiler Version " + VERSION + ":  File " + files[x] + " not found.");
				}
			}
		}
	}

	private static void help() {
		System.out.println("SalsaLite Compiler Version " + VERSION + ":  Usage is one of:");
		System.out.println("         java salsa_lite.compiler.SalsaCompiler < inputfile");
		System.out.println("OR");
		System.out.println("         java salsa_lite.compiler.SalsaCompiler inputfile");
		System.exit(1);
	}

	/**
	 * In some platform, it cannot recognize the wildchars, like *,?, etc.
	 * @param fn
	 */
	private void addFile(String fn) {
		int pos = fn.lastIndexOf(File.separatorChar);
		String dirName, fileName;
		if (pos == -1) {
			dirName = ".";
			fileName = fn;
		}
		else { 
			dirName = fn.substring(0, pos);
			fileName = fn.substring(pos + 1);
		}
		if (fileName.contains("*") || fileName.contains("?")) {
			// It didn't recognize the wildchar
			
			// Replace some chars for java regex
			fileName = fileName.replace(".", "\\.");
			fileName = fileName.replace("?", ".");
			fileName = fileName.replace("*", ".*");
			final String filePattern = fileName;
			File dir = new File(dirName);
			if (dir.exists() && dir.isDirectory()) {
				String[] matchedFiles = dir.list(new FilenameFilter() {
					
					public boolean accept(File dir, String name) {
						return name.matches(filePattern);
					}
				});
				for (String matched : matchedFiles)
					fileList.add(dirName + File.separatorChar + matched);
			}
		} else
			fileList.add(fn);
		// also add the dirname to the classpath
		classPaths.add(dirName);
		
//		if (files == null) {
//			files = new String[1];
//			files[0] = fn;
//		} else {
//			String[] tmp = new String[files.length + 1];
//			System.arraycopy(files, 0, tmp, 0, files.length);
//			tmp[files.length] = fn;
//			files = tmp;
//		}
	}
}
