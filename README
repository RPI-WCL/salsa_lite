Building:
    Make sure the salsa_lite directory is in your classpath.

    To reparse the grammar (and re-generate the compiler files) and recompile salsa run the parse_and_build.sh script.  You'll need JavaCC (the Java Compiler Compiler -- http://javacc.java.net/) installed to be able to modify the grammar and update syntax.

    To just compile everything (without regenerating the compiler files), run the build.sh script.


Running the compiler:
    I recommend using the following alias in your profile to run the salsa compiler:

    alias slc='java salsa_lite.compiler.SalsaCompiler'


Running SALSA programs:
    After running the salsa compiler, then running the java compiler on the generated code:
    java <module>.<ActorName>
    You can set the number of stages used with the -Dnstages=<number of stages> system property. Setting the number of stages controls the number of threads used by the runtime.
    You can set the number of actor registries used with the -Dnregistries<number of registries> system property.  More registries increases the concurrency in serializing actors (because of local deep copy, remote message sending and migration).
    
    Please let us know at salsadev [at] cs.rpi.edu if the SALSA compiler does not display errors or warnings that the Java compiler does.


Notable changes from SALSA 1.x and before:
    *   The compiler now does static typechecking. Error reporting for the compiler has also been greatly improved.
    *   Extended For loop syntax added.
    *   Generics are usable.
    *   All parameters are pass-by-copy.  The compiler will insert a deep copy statement around a mutable object (or array) before it is passed as the argument to a message, or passed as a result from a message.  Previous versions of SALSA had pass-by-reference for local messages, and pass-by-copy for remote messages; this change makes everything pass-by-copy.
    *   When importing Java objects, use (for example) 'import object java.util.LinkedList;'. Objects in java.lang are automatically imported.
    *   void is not a valid return type for a message handler any more, use ack (for acknowledgement).  This better represents the fact that message handlers that don't return a value can still be used in continuations, as they send an acknowledgement.
    *   return statements are now pass statements. ie: use 'pass 10;' instead of 'return 10;'
    *   currentContinuation is not used anymore, instead pass statements are used.  ie: 'a<-m1() @ currentContinuation;' is now 'a<-m1() @ pass;'.  This will pass an acknowledgement as the first class continuation.  If you want to pass the actual value, use: 'pass a<-m1();'.  It is also possible to pass a token: 'token ack t = a<-m1(); pass t;' which has the same semantics as 'pass a<-m1();'.
    *   Join blocks are no longer in the language.  Instead, the JoinDirector actor can be used, see salsa_lite/examples/threadring/ThreadRing.salsa for an example.
    *   StandardOutput and StandardError are first class actors.  To use them you must first create them, ie: 'StandardOutput standardOutput = new StandardOutput(); standardOutput<-println("something");'.
    *   There is no longer an act method, instead, for an actor that can be run from the command line, create a constructor that takes an array of strings. When that actor is run, the constructor with an array of Strings as the argument will be invoked. ie: 'behavior MyActor { void act(String[] arguments) { ... } }' is now 'behavior MyActor { MyActor(String[] arguments() { ... } }'. This reflects the fact that an actor is created when it is run, unlike in java where the main method is a static invocation (and does not create an object).
    *   Salsa now allows for tokens within expressions, eg: 'a<-m1( b<-m2() + c<-m3() * d<-m4() );' will work.
    *   This can also be combined with continuations, eg: 'e<-m5() @ a<-m1( b<-m2() + c<-m3() * d<-m4() ) @ f<-m6();'.
    *   And in pass statements, eg: 'pass a<-m1( b<-m2() + c<-m3() * d<-m4() );'.
    *   It is possible to invoke methods on self.  Because of this, to prevent ambiguity, for an actor to send a message or invoke a method on itself, use either 'self<-message();' or 'self.method();'.  Using 'message()' or 'method()' will not work (we might want to change this, maybe make sending a message the default).
    *   Local actors have automatic garbage collection (using Java's garbage collector), so long as MobileActors with references to them are not migrated to another theater.
    *   You can specify what stage an actor runs on: 'NewActor na = new NewActor() at (<stage number>);' or 'NewActor na = newActor() at (StageService.getStage(anotherActor));' or 'NewActor na = new NewActor() at (StageService.getNewStage());'.
    *   Actors can implement 'StagedActor' which will make them run on their own stage. This is useful for actors with blocking behavior or long running message handlers that may starve other actors running on the same stage.
    *   RemoteActors (actors remotely accessible but not mobile) and MobileActors (actors that are mobile and remotely accessible) have been added, instead of UniversalActor
    *   A reference to a RemoteActor can be created as follows: 'MyActor a = reference MyActor at (<host>, <port>) called (<name>);', or if the RemoteActor is local but the name is known: 'MyActor a = reference MyActor called (<name>);', references to MobileActors can be created similarly, if they are at a known host/port or local.
    *   NameServers are now first class RemoteActors, see salsa_lite.runtime.wwc.NameServer
    *   A reference to a MobileActor can be created via a nameserver (as the above method is unreliable if it has moved):
            NameServer myNameServer = reference NameServer at (<host>, <port>) called (<name>);
            MyMobileActor a = reference MyMobileActor at (myNameServer) called (<name>);
        or:
            NameServer myNameServer = reference NameServer at (<host>, <port>) called (<name>);
            token MyMobileActor a = (MyMobileActor)myNameServer<-get(<name>);

BUGS:
    *   Get the wwc package working again.
    *   Type checking for generics may not completely work not sure about things like <? super Something> and <T, E extends T, F extends E>.
    *   Get interfaces working correctly.  They need special messages that know they were sent using an interface, so they invoke the correct message handler.


TODO:
    *   Add garbage collection support for MobileActors.
    *   Report an error if trying to invoke a static method on a non-static object
    *   Allow self(...) and parent(...) as the first line within constructors to call another or the superclasses's constructor.
    *   Add syntax support for try/catch blocks for Java support.
    *   Add support for access control.  All fields of an actor are private (and can't be shared due to no-shared memory), but methods and constructors should be able to be private, protected, public (or no modifier).
    *   Add a thread pool implementation, to compare the two for a publication.
    *   Need to implement a version of the runtime (SynchronousMailboxStage) that is fair. Right now an actor can enter an infinite loop or execute a blocking method which will starve the other actors on that stage.
    *   Syntax for generic methods needs to be added.
    *   Implement token arrays in the compiler (have them use the language.ArrayDirector class).
    *   Implement message blocks, ie: { a<-m1(); b<-m2(); } @ { c<-m3(); d<-m4() }
    *   Add more compiler tests for generics 
    *   Add compiler tests for token arrays.
    *   Add compiler tests for message blocks.
    *   Add compiler tests for interfaces
    *   Add tests for nested expression directors, ie: a<-m( b<-m( c<-m() + d<-m(), e<-m() ) * f<-m() )
    *   Add tests for method invocations within expression directors, ie: a<-m( Math.log(o.something() + 10 * b<-m()) )

